//----------------------------------> Jai Shree Ram <---------------------------------------//
/* +########################################################################################+
+#%%%%%%%%%%%%%%%%%%%%%%%%#############################################################%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@%*######@*#####*%##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%++*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*+*+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%+++@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
+#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@%#**+*******##%%%@@@@@%*%@@@@@@@%###**#####%%%@@@@@@@@@@%#*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@%#**+==++++++++*+****#####*%#%@%%%###***#*#######%%%@@@@@@@%#*
+#%@@@@@@@@@@@@@@@@@@@@%%#*+++++*##%%%@@%##*****#**#*#*%%%%%%%###%#%%@@%%%%%%%%%@@@@@@@%#*
*#%@@@@@@@@@@@@@@@%##**++++**#%%@@@@@@@@@@@@@@##%%%#%%+%%@@%@@@@%%@@@@@@@@@@@@@@@@@@@@@%#*
*#%@@@@@@@@@@@@%#******##%%@@@@@@@@@@@@@@@@@@@@#-:::::.-#@@@%##*+**@@@@@@@@@@@@@@@@@@@@##*
*#%@@@@@@@@@@%#*+*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@#--:-+*---@@@@#**##@@@@@@@@@@@@@@@@@@@@@##*
*#%@@@@@@@@@%***#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%+----+==#@@@@@@@@@@@@@@%@@@@@@@@@@@@@@@##*
*#%@@@@@@@@%**#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#-::-=+=====*@@@@@@%@@@@@@@%%%@@@@@@@@@@@@##*
*#%%@@@@@%#**%@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@+:::::-===:---+@@@@@@#@@@@@@@@%#@@@@@@@@@@@##*
*#%#@@@%#**#@@@@@@@@@@@@@@@@@@@@@@@@@@#**#*#=----:-++=-----+%@@@@@#%@@@@@@@%%@@@@@@@@@@##*
*##%#***#%@@@@@@@@@@@@@@@@@@@@@@@@@%%++**++-:---==:+*-=*==-:#@@@@@@%%%@@@@@%%@@@@@@@@@@##*
*#%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%+*###=:----=*+.=+.+@%+=*@@@@@@@#%%%%@@@%%@@@@@@@@@@##*
*#%@@@@@@@%%@@@@@@@@@@@@@@%@%%@@@@@#+=+-+----==@@#+..=+%@@@@@@@@@%=+#@@@@@@%@@@@@@@@@@@##*
*#%@@@@@@@@@%%@@@@@@@@@%%%#%@@**%%+-=-------:-=@@%%###+@@%@%@@@@@%#=+#@@@@@%@@@@@@@@@@@##*
*#%@@@@@@@@@@@@%#@@#%#+**++*+*@*=---===-:::::-=#@@@%#%*@@#+==#@@%%@#++*%@@@@@@@@@@@@@@@##*
*#%@@@@@@@@@@@@@@%%%@@@@@@*:+==+==--:::::::--:-+#@@%%%*%#@=:--@%%%@@%*+**#%@@@@@@@@@@@@##*
*#%@@@@@@@@@@@@@@@@@%%%@@%*.--==---..:--:::::---+#%@@%+##+-:-+%%#%@@%@%#*#@@%@@@@@@@@@@##*
*##@@@@@@@@@@@@@@@@@@@@%#%-=+::---:-=-:---:::-=**@@%#+-+=-=+#%#*#@@%@@@@@%%@@@@@@@@@@@@##*
*#%@@@@@@@@@@@@@@@@@@@@@@%+:++=--===-=#@@@@%%%#+#@@#+**%#+%#####@@@@@@%%%@@@@@@@@@@@@@@##*
*#%@@@@@@@@@@@@@@@@@@@@@@@@%+=--==-=*#######*=++###@@#+**#**###@@@@@%%%@@@@@@@@@@@@@@@@##*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@%@@@##*#@@@@@@%%#@%######*+****##%@@@@@%#@@@@@@@@@@@@@@@@@@##*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@%#%%*##%@@@@@@@@@%%#***+**###@@@@@@##%@@@@@@@@@@@@@@@@@@##*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@#%@@@@%#*########*****++###@@@@@@%%%#@@@@@@@@@@@@@@@@@@@##*
*#%@@@@@@@@@@@@@%#***%@@@@@@@@@%#@@@@@@%#%%@@%####**#**%@@@@@@%%@%%#@@@@@@@@@@@@@@@@@@@##*
*#%@@@@@@@@@@@@##%#**#@@@@@@@@%@%%@@@@@%%@@#**#***###*#@@@@@%%@%%@%#@@%%%%@@@@@@@@@@@@@##*
*#%@@@@@@@@@@@%@@@%*+#@@@@@@%+++**##%@@@%%###****#%@@#%@@@##%%%@@@##@%%#%#%%@@@@@@@@@@@##*
*#%@@@@@@@@@@@@@@@%#+%%%@@@%#%%##*+*+*#@%#%####%%%##%**%#%@@@@@@@%#@%@%#####%@@@@@@@@@@##*
*#%@@@@@@@@@@@@@@@%*++#%%@@#%@@@@@@%**%%%%###%@@@@@%###%@@@@@@@@%#@@%%%##*###%@@@@@@@@@##*
*#%@@@@@@@@@@@@@@%#+*++*#%%#%@@@@%%%@@%%%#%%@@@@@%@@@%%%@@@%@@@@#@@@%####*#**%@@@@@@@@@##*
*#%@@@@@@@@@@@@@@%*++++**##*%@%%%%%%@@@@%%%@@@@@@@@@@@%%@%%@@@@%@@@@@##*#*#**%@@@@@@@@@%#*
*#%@@@@@@@@@@@@@@%*++++**###%@@@@@@@@%%%%%**+%@@@@@@%%%@@@%%@@@%@@@@%*#******%@@@@@@@@@%#*
*#%@@@@@@@@@@@@@@@#++++**###%@@@@@@@@@@@@**##@@@@@@@%@@@%%@@@@@@@@@%#*******#@@@@@@@@@@%#*
*#%@@@@@@@@@@@@@@@%#++***###%@@@@@@@@@@@@*###@@%%%@@@@@@@@@@@@@@@@%*******##%@@@@@@@@@@%#*
*#%@@@@@@@@@@@@@@@@@%####%%%##%%%%%%%%@@@@@@@@@@@%#********######*******#*#@@@@@@@@@@@@%#*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@%#*#*###*#%%###**********##%@@@@@@@@@@@@@%#*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%%#****#####%%##%%####%%####%%%@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%%%%%%#***##%%#%%%#%%%%###%%%%%@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%#######%%%%%%%%%%%####%%@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%%#######%%%#%%######%%%@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%#######%##%#######*###%%%@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%####%%%%####*%#%###%%%%%@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@%@@@@@@%%%#%%%%@@@%#****###########%#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@%%%%%%%#####**###**********#########%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@%%%%%#######******#******#***###%#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@%%%%%*#####*#**#%%%%%%#######%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%@@@@@@@@@@@@@@@@@@@@@@%#*****#%@@@@@@@@@@@@%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%*
*#%%%%%%%%%%%%%%%%%%%%%%%#############################################################% */
#include<bits/stdc++.h>
#include<unordered_map> 
using namespace std;
// Code Shortners
#define ub upper_bound
#define lb lower_bound
#define endl "\n"
#define ll long long
#define lli long long int
#define vi vector<int>
#define vc vector<char>
#define vs vector<string>
#define vll vector<ll>
#define vvi vector < vi >
#define vvc vector<vector<char>>
#define vvll vector<vector<ll>>
#define vpll vector<pair<ll,ll>>
#define pii pair<int,int>
#define mll map<ll,ll>
#define pll pair<ll, ll>
#define F first
#define S second
#define pb push_back
#define ppb pop_back
#define pf  push_front
#define ppf pop_front
#define mp make_ pair
#define len(s) (int)s.size()
#define print(x) cout<<x<<endl;
#define REP(i,arr1,arr2) for( int i = arr1; i < arr2; i++)
#define REPE(i,arr1,arr2) for( int i = arr1; i <= arr2; i++)
#define all(arr1) (arr1).begin(), (arr1).end()
#define fast ios_bfse::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define mod 1000000007

//---------------------------------------------------------------------------------------------------------------------

/*
//Hello!! Stalker---->STOP STALKING :)
 
  //Euclid's algorithm----O(logN)
  ll gcd(ll arr1, ll arr2) { if (arr2 == 0) {return arr1;} return gcd(arr2, arr1 % arr2);}
 
//Hello!! Stalker---->STOP STALKING :)
  //LCM
  ll lcm(ll arr1, ll arr2){return (arr1/gcd(arr1,arr2)*arr2);}
 
//Hello!! Stalker---->STOP STALKING :)
  //Prime factorisation----O(sqrt(n))
  vpll primefact(ll n, vll & cntt)  { vpll pfact; 
  for(ll i=2; i*i<=n; i++) if(n%i==0){ll cnt=0; while(n%i==0) {cnt++; n/=i;} cntt[i]+=cnt;}
  if(n>1) cntt[n]++;  return pfact; }
 
//Hello!! Stalker---->STOP STALKING :)
  //Binary Exponentiation(recursive)---divide & conquer-----> O(log arr2)
  ll powerRec(ll arr1, ll arr2) { 
  if(arr2==0) return 1;
  ll store = powerRec(arr1, arr2/2);
  if(arr2&1) {return (arr1* ((store*store) %mod)) %mod;} else{ return (store*store) %mod;} }
 
//Hello!! Stalker---->STOP STALKING :) 
  //Binary Exponentiation(iterative)---divide & conquer-----> O(log arr2)
  ll powerIter(ll arr1, ll arr2){
    ll ans=1;
    while(arr2){ if(arr2&1) { ans=(ans*arr1);} arr1=(arr1*arr1); arr2>>=1;} return ans;
  }
 
 //
ll inv(ll i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}
 
ll mod_mul(ll arr1, ll arr2) {arr1 = arr1 % mod; arr2 = arr2 % mod; return (((arr1 * arr2) % mod) + mod) % mod;}
 
ll mod_add(ll arr1, ll arr2) {arr1 = arr1 % mod; arr2 = arr2 % mod; return (((arr1 + arr2) % mod) + mod) % mod;}
 
ll mod_sub(ll arr1, ll arr2) {arr1 = arr1 % mod; arr2 = arr2 % mod; return (((arr1 - arr2) % mod) + mod) % mod;}
 
 //
//Hello!! Stalker---->STOP STALKING :)
  // Sieve of Erastosthenes---> O(n* log(logn))
   vector<ll> sieve(int n) {vll arr(n+1,0); vector<ll> vect; 
    arr[1]=1;
  for (int i = 2; i <= n; i++)
  if (arr[i] == 0) {arr[i]=i; 
  for (int j = 2 * i; j <= n; j += i)arr[j] = i;} return arr;}
 
//Hello!! Stalker---->STOP STALKING :)
  //sum_of_digits
  ll sum_of_digits(ll n) {ll sum=0; while(n>0) {sum+=n%10; n/=10; } return sum;}
 
//Hello!! Stalker---->STOP STALKING :)
  // Prime or not-----O(sqrt(n))
  bool isPrime(ll n)
  {if(n==1) return false; for(ll i=2; i<=sqrt(n); i++){ if(n%i==0) return false;} return true;}
 
//Hello!! Stalker---->STOP STALKING :)
  //Perfect square or not----->O(1)
  bool prfSq (ll n){ if(ceil(double(sqrt(n)) == floor(double(sqrt(n))))){ return 1; }else{ return 0;}}
 
//Hello!! Stalker---->STOP STALKING :)
//factorial of arr1 no.----->O(n)
vll factt(ll n){
    vll fact(n+1,1);
    ll factorial=1;
    for(ll i=1; i<=n; i++){
      (fact[i]=(fact[i-1]*i))%=mod;
    }
    
    return fact;
  }



ll sqrtt(ll x){
  ll left = 0, right = 2000000123;
  while (right > left) {
    ll mid = (left + right) / 2;
    if (mid * mid > x) right = mid;
    else left = mid + 1;
  }
  return left - 1;
}

 
 
//Hello!! Stalker---->STOP STALKING :)
// regulr bracket string or not
bool regular(string arr1){
  ll cnt=0;
  for(ll i=0; i<arr1.length(); i++){
    if(arr1[i]=='(') cnt++;
    else cnt--;
    if(cnt<0) return false;
  }
  if(cnt>0) return false;
  return true;
}
 
//Hello!! Stalker---->STOP STALKING :)
//Reverse arr1 number
vector<int> reverse_no(ll n){
    vi vec2;
    ll ans=0, rem;
    while(n != 0) {
    rem = n % 10;
    vec2.pb(rem);
    ans = ans * 10 + rem;
    n /= 10;
  }
  return vec2;
}

//**************************************************************************************************
 
//Hello!! Stalker---->STOP STALKING :)
ll countPrimes(ll n){
  if(n<2) return 0;
  int count=0;
  vector<bool> primes(n,1);
  primes[0] = false;
  primes[1] = false;
  for(ll i=2;i<n;i++){
    if(primes[i]){
      count++;
      for(ll j=i*i;j<n;j+=i) primes[j]=0;
    }
  }
  return count;
}
 
//Hello!! Stalker---->STOP STALKING :)
ll countDigit(ll n){
  ll count = 0;
  while (n != 0){
    n = n / 10;
    ++count;
  }
  return count;
}
 
//Hello!! Stalker---->STOP STALKING :)
// number is power of 2 or not
bool check(ll n){
  if(n==0) return false;
  return (ceil(log2(n)) == floor(log2(n)));
}

//---------------------------------------------------------------------------------------------------------------------

//pallendrome (two pointer)
bool ispalindrome(string s){
  ll i=0, j=s.length()-1;
  while(i<=j){
    if(s[i]!=s[j]) {return false;  break;}
    i++;
    j--;
  }
  return true;
}
 

//---------------------------------------------------------------------------------------------------------------------

//String Compare
bool comp(pair<int,string>&arr1, pair<int,string>&arr2){
  if(arr1.first<arr2.first) return true;
  else if(arr1.first==arr2.first) return arr1.second<=arr2.second;
  else return false;
}

//---------------------------------------------------------------------------------------------------------------------

//Is Vowel
 bool isvowel(char x){
  int p=int(x);
  if (x == 97 || x == 101 || x == 105 || x == 111 || x == 117 || x==65 || x==69 || x==73 || x==79 || x==85) return true;
  else return false;
}

//---------------------------------------------------------------------------------------------------------------------

//Dijkstra 
vll dijkstra(ll V, vpll A[], ll S){
  priority_queue<pii,vector<pii>,greater<pii>>pq;
  vll dist(V+1,1e9+7);
  dist[S]=0;
  pq.push({0,S});
  while(!pq.empty()){
    ll dis=pq.top().first;
    ll prev=pq.top().second;
    pq.pop();
    for(auto child:A[prev]){
      ll next=child.f;
      ll nextDist=child.s;
      if(dist[next]>dist[prev]+nextDist){
        dist[next]=dist[prev]+nextDist;
        pq.push({dist[next],next});
      }
    }
  }
  return dist;
}

//---------------------------------------------------------------------------------------------------------------------


//Shortest Distance
void shortest_distance(vector<vector<int>>&d){
  int n = d.size();
  for(int k=0;k<n;k++){
      for(int i=0;i<n;i++){
          for(int j=0;j<n;j++){
              if(d[i][k]==-1 || d[k][j]==-1)continue;
              if(d[i][j]==-1)   d[i][j] = d[i][k] + d[k][j];
              else d[i][j] = min(d[i][j],d[i][k] + d[k][j]);
          }
      }
  }
}


//---------------------------------------------------------------------------------------------------------------------


vpll dir4={{1,0},{-1,0},{0,1},{0,-1}};
vpll dir8={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,-1}};
vpll knight_moves={{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};


//---------------------------------------------------------------------------------------------------------------------

//Vaild
bool valid(ll x, ll y, ll n, ll m){
  return x>=0 && x<n && y>=0 && y<m;
}

//---------------------------------------------------------------------------------------------------------------------


//DFS
void dfs(ll i, ll j, ll n, ll m, vvc &arr1, vvi &vis,ll &cnt){
  vis[i][j]=1;
  cnt++;
  for(auto x:dir4){
    ll p=i+x.f, q=j+x.s;
    if(valid(p,q,n,m) && !vis[p][q] && arr1[p][q]=='1') dfs(p,q,n,m,arr1,vis,cnt);
  }
}


//---------------------------------------------------------------------------------------------------------------------


// Returns nCr % p using Fermat's little theorem.
ll nCrModPFermat(ll n,ll r, ll p){
    // If n<r, then nCr should return 0
    if (n < r) return 0;
    // Base case
    if (r == 0) return 1;
    // Fill factorial array so that we
    // can find all factorial of r, n
    // and n-r
    ll fac[n + 1];
    fac[0] = 1;
    REPE(i,1,n)
        // fac[i] = mod_mul(fac[i-1],i);
        return (fac[n] * modInverse(fac[r], p-2,p) % p * modInverse(fac[n - r], p-2,p) % p) % p;
}
*/
//---------------------------------------------------------------------------------------------------------------------

bool sol(vi &v1, vi& v2) {
    
    int cnt = 0,sid;
    unordered_map<int, int> mp1;
    REP(ind, 0, v1.size()) mp1[v2[ind]] = ind;
    
    
    
   REP(i, 0, v1.size()) {
        if (v1[i] != v2[i]) {
            
            sid = mp1[v1[i]];
            swap(v2[i], v2[sid]);
            mp1[v1[i]] = i;
            mp1[v2[sid]] = sid;
            cnt+=1;
            
        }
    }
    if (cnt % 2 == 0) return true;
    else return false;
}


int main(){
  ll t; cin>>t;
  while(t--){
        int n; cin >> n;
        vi arr1(n);
        REP(i, 0, n) cin >> arr1[i];
        vi arr2(n);
        REP(i, 0, n) cin >> arr2[i];
        
        vi vec1 = arr1, vec2 = arr2;
        sort(all(vec1));
        sort(all(vec2));
        
        if (vec1 != vec2) {
            print("NO");
        } else {
            print((sol(arr1, arr2) ? "YES" : "NO")); 
        }
  }
  return 0;
}

